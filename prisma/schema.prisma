datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                     String    @id @default(cuid())
  email                  String    @unique
  nickname               String
  password               String
  resetToken             String?
  resetTokenExpiry       DateTime?
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt

  lists                    List[]
  reservations             Reservation[]
  createdSecretSantas      SecretSanta[]               @relation("SecretSantaCreator")
  secretSantaParticipations SecretSantaParticipant[]
  sentSecretSantaInvitations SecretSantaInvitation[]   @relation("InvitationSender")
  receivedSecretSantaInvitations SecretSantaInvitation[] @relation("InvitationReceiver")
  sentListInvitations      ListInvitation[]            @relation("ListInvitationSender")
  receivedListInvitations  ListInvitation[]            @relation("ListInvitationReceiver")
}

model List {
  id          String   @id @default(cuid())
  title       String
  description String?
  deadline    DateTime
  isPublic    Boolean  @default(false)
  shareToken  String   @unique
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  gifts       Gift[]
  invitations ListInvitation[]
}

model Gift {
  id          String   @id @default(cuid())
  name        String
  description String?
  links       String? // JSON array of links
  priority    String   @default("MOYEN") // FAIBLE, MOYEN, HAUT, TRES_HAUT
  quantity    Int      @default(1)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  listId String
  list   List   @relation(fields: [listId], references: [id], onDelete: Cascade)

  reservations Reservation[]
}

model Reservation {
  id        String   @id @default(cuid())
  quantity  Int      @default(1)
  createdAt DateTime @default(now())

  giftId String
  gift   Gift   @relation(fields: [giftId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([giftId, userId])
}

model SecretSanta {
  id          String   @id @default(cuid())
  title       String
  description String?
  deadline    DateTime
  maxAmount   Float?   // Montant maximum suggéré
  status      String   @default("DRAFT") // DRAFT, ACTIVE, COMPLETED
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  creatorId String
  creator   User   @relation("SecretSantaCreator", fields: [creatorId], references: [id], onDelete: Cascade)

  participants SecretSantaParticipant[]
  invitations  SecretSantaInvitation[]
}

model SecretSantaParticipant {
  id           String   @id @default(cuid())
  joinedAt     DateTime @default(now())
  
  // Attribution : qui offre à qui
  assignedToId String?  // ID du participant à qui cette personne doit offrir
  assignedTo   SecretSantaParticipant? @relation("SecretSantaAssignment", fields: [assignedToId], references: [id], onDelete: SetNull)
  assignedFrom SecretSantaParticipant[] @relation("SecretSantaAssignment")

  secretSantaId String
  secretSanta   SecretSanta @relation(fields: [secretSantaId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([secretSantaId, userId])
}

model SecretSantaInvitation {
  id        String   @id @default(cuid())
  email     String
  token     String   @unique
  status    String   @default("PENDING") // PENDING, ACCEPTED, DECLINED
  sentAt    DateTime @default(now())
  respondedAt DateTime?

  secretSantaId String
  secretSanta   SecretSanta @relation(fields: [secretSantaId], references: [id], onDelete: Cascade)

  senderId String
  sender   User   @relation("InvitationSender", fields: [senderId], references: [id], onDelete: Cascade)

  // Si l'invité a un compte
  receiverId String?
  receiver   User?   @relation("InvitationReceiver", fields: [receiverId], references: [id], onDelete: SetNull)

  @@unique([secretSantaId, email])
}

model ListInvitation {
  id        String   @id @default(cuid())
  email     String
  token     String   @unique
  status    String   @default("PENDING") // PENDING, ACCEPTED, DECLINED
  sentAt    DateTime @default(now())
  respondedAt DateTime?

  listId String
  list   List   @relation(fields: [listId], references: [id], onDelete: Cascade)

  senderId String
  sender   User   @relation("ListInvitationSender", fields: [senderId], references: [id], onDelete: Cascade)

  // Si l'invité a un compte
  receiverId String?
  receiver   User?   @relation("ListInvitationReceiver", fields: [receiverId], references: [id], onDelete: SetNull)

  @@unique([listId, email])
}
